Установка
---

Для `Linux 18` по дефолту используется Postgres `12.16` версии. 

    sudo apt install postgresql postgresql-contrib

При установке программа pg создаст пользователя `postgres` в самой 
СУБД, а также создаст нового пользователя в самой системе Linux
с таким же названием `postgres`. Это делается из-за того что pg создает
идентичную аутентификацию, что значит что каждой роли в самой СУБД 
сопоставляется такая же роль в Linux.  

Это можно увидеть командой:

    // Команда выводит всех пользователей в Linux
    cat /etc/passwd

    // Вывод
    ...
    ...
    serg:x:1000:1000:serg,,,:/home/serg:/bin/bash
    redis:x:122:127::/var/lib/redis:/usr/sbin/nologin
    sshd:x:123:65534::/run/sshd:/usr/sbin/nologin
    mysql:x:124:128:MySQL Server,,,:/nonexistent:/bin/false
    postgres:x:125:129:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash

---
Аутентификация
---

`PG` устанавливает идентичную аутентификацию, то есть если роль есть в PG 
то `PG` ассоциирует свои роли с ролями в `Unix`, и пользователь `Linux` может 
войти в `PG` под тем же именем.

При начальной настройке конфиг файла `pg_hba.conf` который находится по 
пути `/etc/postgres/10/main/pg_hba.conf` устанавливает следующие правила:

    # Database administrative login by Unix domain socket
    # TYPE       DATABASE      USER            METHOD
    local        all           postgres        peer

По дефолту можно соединяться как Linux пользователь `postgres` при 
помощи следующей команды `sudo -u postgres psql` то есть входим в pg
как `postgres` пользователь.

**`USER postgres` и `METHOD peer`** - указывают что подключится может только
пользователь `postgres` и только со входом от `Linux` на том же юзере.

Если поменять на следующее **`USER postgres` и `METHOD trust`** - то тогда 
метод trust укажет что теперь можно подключаться не только с начальным 
переходом в соответствующего пользователя в самой `Linux` системе, но и 
просто с использованием команды `psql` то есть следующим образом:

```
    psql -U postgres
```

Но это будет работать только для пользователя `postgres` но не для всех 
остальных, что бы изменить это сделаем так:

```
    # Database administrative login by Unix domain socket
    # TYPE       DATABASE      USER            METHOD
    local        all           all             trust
```

Незабываем перезагружать сервис после изменения конфиг файлов.
    
```
   sudo service postgresql restart
```

Теперь можно соединяться любым пользователем предварительно не переходя в 
режим соответствующего пользователя в самом Linux, то есть можем войти в 
pg к примеру таким образом:

```
    psql -U user1 
```

Кончено вход произойдет если под этого пользователя уже создана 
соответствующая БД с таким же названием, как и у самого пользователя.

Но даже в случае если пользователь существует, но для него не создана БД 
с таким же названием, мы все равно можем войти в pg, но уже для этого 
потребуется указание конкретной БД к которой будем соединяться.

К примеру так: `psql -U user3 demo` мы указываем пользователя `user3` такой 
юзер есть, но для него не создано БД, в место этого мы указываем БД demo 
и соединяемся с ней.

---
Сессии соединений пользователей к БД, и удаление БД
---

При работе пользователя с Бд создается сессия пользователя, все сессии
можно посмотреть в таблице `pg_stat_activity` следующим запросом:

    SELECT * FROM pg_stat_activity;

Если открыта сессия пользователя на работу с БД, то пока сессия открыта 
удалить БД не получиться.

Вот как это выглядит, тут можно увидеть id пользователей их имена 
и `pid` их процессов, тут колонка `datname` указывает БД к которой 
соединение.

    datid | datname |  pid  | usesysid | usename  | application_name |
    -------+---------+-------+----------+----------+------------------+
    16386 | user1   |  9923 |    16384 | user1    | psql             |
    16386 | user1   | 21809 |    16384 | user1    | psql             |

То есть можно отсортировать при помощи `SQL` запроса сколько есть 
подключений к конкретной БД при помощи следующего запроса:

    SELECT pg_terminate_backend(pg_stat_activity.pid)
    FROM pg_stat_activity
    WHERE pg_stat_activity.datname = 'user1' AND 
    pid <> pg_backend_pid();

После этого можно удалить БД

    DROP DATABASE user1;
