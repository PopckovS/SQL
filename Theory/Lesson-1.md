№ 1
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
SELECT *
FROM 
     film AS f
GROUP BY 
     rental_duration;
```
####Ответ:
Это вопрос на знание группировок, группировки применяются на некое поле,
при этом при группировке, самом блоке SELECT должны находится либо поля по
которым мы группируем, или поля на которые применяются агрегатные функции.

В данном примере, есть подвох, если в таблице всего 1 поле и это поле
`rental_duration` тогда запрос сработает, иначе получим ошибку, ибо символ 
`*` укажет все поля таблицы, по которым не будет ни группировки ни 
агрегатных функций.

```sql
-- Это сработает, ибо мы используем 2 поля, на которые есть либо
-- группировка либо агрегатная функция
SELECT max(rental_rate), rental_duration 
FROM film AS f
GROUP BY rental_duration;

-- Это сработает ибо мы группируем по одному полю и его же извлекаем
SELECT rental_duration 
FROM film AS f
GROUP BY rental_duration;
```
---

№ 2
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
select field1 from TABLE1 group by field1, field2
```
####Ответ:
Да, все сработает нормально, группировать и отсеивать в блоках:
WHERE, GROUP BY можно по тем полям которые не будут включены в 
выборку.
---

№ 3
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
select field1, field2 
from TABLE1 
group by field1, field2 
having field2 = 0
```
####Ответ:
Да все сработает, блок HAVING сортирует группировки, и сделать это 
можно, просто на практике HAVING используется редко, по этому можно
просто забыть как это работает.
---

№ 4
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
UPDATE TABLE1 
SET field1 = row_number() 
FROM TABLE1
```
####Ответ:
row_number() — это часть аналитической функции, которая не может
быть применена сама по себе. Аналитические функции
используются только в конcтрукциях SELECT или ORDER BY.
---

№ 5
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
INSERT INTO TABLE1 (field1, field2, field3) 
VALUES ('1','2')
```
####Ответ:
Это не сработает, количество столбцов в `INTO` и в `VALUES` должно 
быть одинаковое, даже в случае если у столбца `field3` есть некотрое 
значение по дефолту, все равно их количество должно быть одинаковым.

```sql
-- Внесет данные  602,	"NEW COUNTRY",	100, 2021-07-24 02:33:53
INSERT INTO city
(city, country_id, last_update)
VALUES ( 'NEW COUNTRY', 100, now())

-- Это не сработает, при внесении данных, количество
-- вносимых данных должно быть одинаковое
INSERT INTO city
(city, country_id, last_update)
VALUES ( 'NEW COUNTRY', 100)
```
---

№ 6
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
delete from TABLE1 
having count(field1) > 1
```
####Ответ:
Нет не сработает, HAVING фильтрует только группировки, и не 
используется для удаления.

---

№ 7
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
truncate TABLE1

```
####Ответ:
Нет не сработает, пропущено слово `TABLE` также можно задать
дополнительный вопрос: чем отличается `truncate table TABLE1` от 
`delete from TABLE1?` `Truncate` — это `DDL`-операция, т.е.
операция изменения объекта в базе. Она выполняется
намного быстрее. `Delete` — это операция `DML`, т.е. операция
с данными внутри таблицы. Опытный разработчик должен знать 
нюансы SQL.

`Truncate` — это `DDL`- операция, операция изменения обьекта что
находится в БД.

`Delete` — это операция `DML`, т.е. операция с данными внутри таблицы.

Правильный вариант выглядит так:
```sql
TRUNCATE TABLE TABLE1; 
```

---

№ 8
---
####Вопрос:
Что такое `CROSS JOIN` ?
####Ответ:
`CROSS JOIN` единственный джоин, который не требует связки 
между таблицами с помощью оператора `ON`, этот джоин связывает
все поля одной таблицы со всеми полями другой таблицы, то есть
создает декартово произведение всех полей между 2 таблицами.

Пример:
Есть 2 таблицы actor и film_actor, в film_actor есть 5462
строчек, из которых 19 записей имеют в поле actor_id = 1 
в таблице actor есть всего 200 записей вообще при подобном
запросе мы получим декартово произведение всех
строк одной таблицы на все строки другой таблицы.

200 * 5462 = 1092400 

Столько строк получим в результате следующего SQL запроса:
```sql
-- Получим 200 * 5462 = 1092400 Строчек 
SELECT * 
FROM actor AS a 
CROSS JOIN film_actor AS fa;
```
Также в место `CROSS JOIN` есть другой механизм, что действует
точно также, то есть дает декартово произведение, это указание
2 и более источников в блоке `FROM` 

```sql
-- Получим все те же 200 * 5462 = 1092400 Строчек
SELECT * 
FROM 
    actor AS a, 
	film_actor AS fa
;
```

---

№ 9
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
SELECT * 
FROM table1 AS t 
    INNER JOIN table2 AS tt ON 1 = tt.field1
```
####Ответ:
Так ... вот это задачка !

Тут довольно интересно, это не даст ошибки, будет выполнено 
нормально, по сути произойдет вот что, если бы мы сделали
`CROSS JOIN` одной таблицы на другую таблицу, а потом
сделаем выборку, где поле = 1

К примеру так:
```sql
SELECT * 
FROM table1 AS t CROSS JOIN table2 AS tt
WHERE tt.field1 = 1
; 
```

К примеру сделая `CROSS JOIN` а потом делаем выборку по полю:

```sql
SELECT * FROM actor AS a 
CROSS JOIN film_actor AS fa
WHERE a.actor_id = 1
;
```

И так в чем суть, нас есть 2 запроса, один запрос делает 
`CROSS JOIN` и потом при помощи `WHERE` выбрать где поле = 1, 
другой запрос делает этот странный трюк 
`INNER JOIN film_actor AS fa ON 1 = fa.actor_id`
но в результате мы получаем абсолютно одинаковый результат:
```sql
-- Получим 3800 строк
SELECT * FROM actor AS a 
CROSS JOIN film_actor AS fa
WHERE fa.actor_id = 1
;

-- Получим 3800 строк
SELECT * 
FROM actor AS a
INNER JOIN film_actor AS fa ON 1 = fa.actor_id
;
```
---










№ ?
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql

```
####Ответ:

---







