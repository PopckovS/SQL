№ 1
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
SELECT *
FROM 
     film AS f
GROUP BY 
     rental_duration;
```
####Ответ:
Это вопрос на знание группировок, группировки применяются на некое поле,
при этом при группировке, самом блоке SELECT должны находится либо поля по
которым мы группируем, или поля на которые применяются агрегатные функции.

В данном примере, есть подвох, если в таблице всего 1 поле и это поле
`rental_duration` тогда запрос сработает, иначе получим ошибку, ибо символ 
`*` укажет все поля таблицы, по которым не будет ни группировки ни 
агрегатных функций.

```sql
-- Это сработает, ибо мы используем 2 поля, на которые есть либо
-- группировка либо агрегатная функция
SELECT max(rental_rate), rental_duration 
FROM film AS f
GROUP BY rental_duration;

-- Это сработает ибо мы группируем по одному полю и его же извлекаем
SELECT rental_duration 
FROM film AS f
GROUP BY rental_duration;
```
---

№ 2
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
select field1 from TABLE1 group by field1, field2
```
####Ответ:
Да, все сработает нормально, группировать и отсеивать в блоках:
WHERE, GROUP BY можно по тем полям которые не будут включены в 
выборку.
---

№ 3
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
select field1, field2 
from TABLE1 
group by field1, field2 
having field2 = 0
```
####Ответ:
Да все сработает, блок HAVING сортирует группировки, и сделать это 
можно, просто на практике HAVING используется редко, по этому можно
просто забыть как это работает.
---

№ 4
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
UPDATE TABLE1 
SET field1 = row_number() 
FROM TABLE1
```
####Ответ:
row_number() — это часть аналитической функции, которая не может
быть применена сама по себе. Аналитические функции
используются только в конcтрукциях SELECT или ORDER BY.
---

№ 5
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
INSERT INTO TABLE1 (field1, field2, field3) 
VALUES ('1','2')
```
####Ответ:
Это не сработает, количество столбцов в `INTO` и в `VALUES` должно 
быть одинаковое, даже в случае если у столбца `field3` есть некотрое 
значение по дефолту, все равно их количество должно быть одинаковым.

```sql
-- Внесет данные  602,	"NEW COUNTRY",	100, 2021-07-24 02:33:53
INSERT INTO city
(city, country_id, last_update)
VALUES ( 'NEW COUNTRY', 100, now())

-- Это не сработает, при внесении данных, количество
-- вносимых данных должно быть одинаковое
INSERT INTO city
(city, country_id, last_update)
VALUES ( 'NEW COUNTRY', 100)
```
---

№ 6
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
delete from TABLE1 
having count(field1) > 1
```
####Ответ:
Нет не сработает, HAVING фильтрует только группировки, и не 
используется для удаления.

---

№ 7
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
truncate TABLE1

```
####Ответ:
Нет не сработает, пропущено слово `TABLE` также можно задать
дополнительный вопрос: чем отличается `truncate table TABLE1` от 
`delete from TABLE1?` `Truncate` — это `DDL`-операция, т.е.
операция изменения объекта в базе. Она выполняется
намного быстрее. `Delete` — это операция `DML`, т.е. операция
с данными внутри таблицы. Опытный разработчик должен знать 
нюансы SQL.

`Truncate` — это `DDL`- операция, операция изменения обьекта что
находится в БД.

`Delete` — это операция `DML`, т.е. операция с данными внутри таблицы.

Правильный вариант выглядит так:
```sql
TRUNCATE TABLE TABLE1; 
```

---

№ 8
---
####Вопрос:
Что такое `CROSS JOIN` ?
####Ответ:
`CROSS JOIN` единственный джоин, который не требует связки 
между таблицами с помощью оператора `ON`, этот джоин связывает
все поля одной таблицы со всеми полями другой таблицы, то есть
создает декартово произведение всех полей между 2 таблицами.

Пример:
Есть 2 таблицы actor и film_actor, в film_actor есть 5462
строчек, из которых 19 записей имеют в поле actor_id = 1 
в таблице actor есть всего 200 записей вообще при подобном
запросе мы получим декартово произведение всех
строк одной таблицы на все строки другой таблицы.

200 * 5462 = 1092400 

Столько строк получим в результате следующего SQL запроса:
```sql
-- Получим 200 * 5462 = 1092400 Строчек 
SELECT * 
FROM actor AS a 
CROSS JOIN film_actor AS fa;
```
Также в место `CROSS JOIN` есть другой механизм, что действует
точно также, то есть дает декартово произведение, это указание
2 и более источников в блоке `FROM` 

```sql
-- Получим все те же 200 * 5462 = 1092400 Строчек
SELECT * 
FROM 
    actor AS a, 
	film_actor AS fa
;
```

---

№ 9
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
SELECT * 
FROM table1 AS t 
    INNER JOIN table2 AS tt ON 1 = tt.field1
```
####Ответ:
Так ... вот это задачка !

Тут довольно интересно, это не даст ошибки, будет выполнено 
нормально, по сути произойдет вот что, если бы мы сделали
`CROSS JOIN` одной таблицы на другую таблицу, а потом
сделаем выборку, где поле = 1

К примеру так:
```sql
SELECT * 
FROM table1 AS t CROSS JOIN table2 AS tt
WHERE tt.field1 = 1
; 
```

К примеру сделая `CROSS JOIN` а потом делаем выборку по полю:

```sql
SELECT * FROM actor AS a 
CROSS JOIN film_actor AS fa
WHERE a.actor_id = 1
;
```

И так в чем суть, нас есть 2 запроса, один запрос делает 
`CROSS JOIN` и потом при помощи `WHERE` выбрать где поле = 1, 
другой запрос делает этот странный трюк 
`INNER JOIN film_actor AS fa ON 1 = fa.actor_id`
но в результате мы получаем абсолютно одинаковый результат:
```sql
-- Получим 3800 строк
SELECT * FROM actor AS a 
CROSS JOIN film_actor AS fa
WHERE fa.actor_id = 1
;

-- Получим 3800 строк
SELECT * 
FROM actor AS a
INNER JOIN film_actor AS fa ON 1 = fa.actor_id
;
```

---

№ 10
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
SELECT 
       id,
       sum(value) over(PARTITION BY i ORDER BY y), 
       * 
FROM table1
```
####Ответ:

Да это сработает, это типичный и абсолютно правильный способ
применения аналитической функции (оконной функции), следующий
запрос тоже сработает, с начала извлекаем `payment_id` потом
извлекаем все поля в таблице, дублированием поля `payment_id`
а после к каждой строке мы добавляем сумму всех платежей внутри
их группы, под группой подразумевается, группы разделенные по 
совпадающим `customer_id` так как если бы мы сделали группировку 
по полю `customer_id`, а после внутри каждой из групп все
сортируется по полю `amount`.

```sql
SELECT 
	payment_id,
	*,
	sum(amount) OVER(PARTITION BY customer_id ORDER BY amount) 
FROM payment AS p; 
```

---

№ 11
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
select count(*) from table1 ,table2
```
####Ответ:
Да это сработает, получим количество строчек, равное количеству
декартово произведения одной таблицы на другую таблицу, к
примеру так

```sql
-- 1092400 Строчек получим
SELECT * FROM actor, film_actor;

-- Ответ: 1092400
SELECT count(*) FROM actor, film_actor;
```

---

№ 12
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql
select * 
from table1 
where 
      null = null or null <> null or 123 <> null or null is null
```
####Ответ:
Да, вернет. Причина в последнем условии null is null. 
Оно указано правильно. Дело в том, что при операции 
сравнения (=, <> , > , <) значения null c каким-либо
числом или полем всегда возвращается значение FALSE.
Т.е. синтаксический запрос написан правильно и не упадет,
но он отсекает строки.

NULL в базах данных — это специальное значение, которое
может быть записано в поле таблицы. NULL соответствует
понятию «пустое поле», т.е. «поле, не содержащее никакого
значения». Но его нельзя сравнивать константой. 
NULL можно сравнивать только через оператор is т.е.
null is null или field1 is null.
---

№ 13
---
####Вопрос:
Вывести все записи из таблицы,тсортировать их по возрастанию но 
все `0` должны быть в конце.
####Ответ:
Создаем искуственную сортировку при помощи конструкции `CASE`
если значение равно `0` то оно получает ценность сортировки `2`
и идет в конец, если значение не `0` то ценность сортировки равнв 
`1`

Таким образом все не нули идут в первую очередь, все нули идут 
в конец, но при этом в нутри своих блоков все эти значения не 
отсортированы, по этому после всего этого добавляем сортировку по
возрастанию, в нутри своих блоков.
```sql
SELECT *
FROM payment AS p
ORDER BY 
	CASE amount
		WHEN 0 THEN 2
		ELSE 1
	END, amount 
;
```

---









№ ?
---
####Вопрос:
Выполнится ли данный запрос ? 
```sql

```
####Ответ:

---







