Последовательности `SEQUENCE`
---
Сущность последовательностей можно сравнить с итераторами в `python`, это
счетчик чисел, который увеличивается при каждом обращении к нему на 1, и не
возвращается к прошлому значению.

Функции последовательностей:

1. `nextval('<название последовательности>')` - при каждом обращении увеличивает
счетчик последовательности на 1.
2. `currval('<название последовательности>')` - всегда получает текущее значение 
последовательности.

```sql
-- создание последовательности с названием `seq_1`
CREATE SEQUENCE seq_1; 

-- автоинкрементация последовательности на 1 еденицу
SELECT nextval('seq_1');

-- получение текущего значения последовательности
SELECT currval('seq_1');
```

Все последовательности хранятся в системной таблице `information_schema."sequences"`
получим информацию о созданной последовательности:

```sql
SELECT * 
FROM information_schema."sequences"
WHERE sequence_name = 'seq_1';
```

Что мы увидим, место хранения последовательности, и ее тип данных, по дефолту 
это `bigint`, тут же есть описание начального и минимально возможного значения,
значение на которое увеличивается последовательность и максимальное значение.

| sequence_catalog | sequence_schema | sequence_name | data_type |
|------------------|:---------------:|--------------:|----------:|
| user1            |     public      |         seq_1 |    bigint |

| start_value | minimum_value |       maximum_value |   increment | cycle_option |
|-------------|:-------------:|--------------------:|------------:|-------------:|
| 1           |       1       | 9223372036854775807 |           1 |           NO |

В структуре данных мы можем увидеть как все последовательности хранятся в 
каталоге `Sequences`

![ Структура ](img/seq_1.png)

---
Таблицы и последовательности
---

Для понимания, что такое последовательности, давайте начнем с самого начала,
создадим таблицу, в самой ее базовой форме, без каких либо последовательностей,
первичных ключей и автоинкрементаций, в этой таблице есть только столбцы и 
ничего более. 

```sql
-- Создадим таблицу
BEGIN;

CREATE TABLE "table_1" 
(
 "id" integer NULL, 
 "name" varchar(255) NULL, 
 "title" varchar(255) NULL, 
 "count" integer Null
);

COMMIT;

-- Внесем данные
INSERT INTO public.table_1 (id, "name", title, count) VALUES(1, '11', '111', 1111);
INSERT INTO public.table_1 (id, "name", title, count) VALUES(2, '22', '222', 2222);
INSERT INTO public.table_1 (id, "name", title, count) VALUES(1, '11', '111', 1111);
INSERT INTO public.table_1 ("name", title, count) VALUES('33', '333', 3333);
```

Получившаяся таблица:

| id   | name | title | count |
|------|:----:|------:|------:|
| 1    |  11  |   111 |   111 |
| 2    |  22  |   222 |   222 |
| 1    |  11  |   111 |   111 |
| NULL |  33  |   333 |  3333 |

Как можем видеть, это просто таблица с 4 столбцами, по скольку для таблицы не 
определен ни `AUTOINCREMENT` ни `PRIMARY KEY` то записи могут полностью 
дублироваться, из-за чего нельзя обеспечить уникальность каждой конкретной строки,
так и в столбце `id` могут быть пустые значения, по скольку поле не 
автоинкрементируется, и значению в нем просто неоткуда появиться.

---

В самом начале мы уже создали последовательность с названием `sqe_1` которая 
по дефолту создается с типом `bigint`, несколько раз вызвав команду 
`SELECT nextval('seq_1')` мы увеличили счетчик последовательности до числа `18`.

Теперь создадим новую таблицу, указывая в качестве дефолтного значения конструкцию
`DEFAULT (nextval('seq_1'))` тем самым мы говорим что при создании новой строки в 
данной таблице следует для столбца `id` брать значение из функции `nextval('seq_1')`
которая возвращает новое значение последовательности, таким образом последовательность
связана с таблицей.

```sql
BEGIN;
CREATE TABLE "table_2" 
(
 "id" bigint NOT NULL PRIMARY KEY DEFAULT (nextval('seq_1')), 
 "name" varchar(255) NULL UNIQUE
);
COMMIT;

INSERT INTO table_2 (name) VALUES('hello world 1') RETERNING id;
INSERT INTO table_2 (name) VALUES('hello world 2') RETERNING id;

-- Результат
19
20
```

---
Опции последовательностей
---

`OWNED BY <table-name.column-name>` - Но удаление таблицы, не влечет за собой
удаление последовательности, если подразумевается что последовательности неразрывно
связана со столбцом таблицы, и удаление таблицы должно влечь за собой и удаление
последовательности, то при создании последовательности можно указать параметр
`OWNED BY table_2.id` это удалит последовательности при удалении таблицы.

---

`CYCLE` или `NO CYCLE` - если не указана то по дефолту это `NO CYCLE`, указывает
как себя вести при достижении максимального значения последовательности, если
указано `NO CYCLE` то по достижению максимального значения будет возвращена ошибка,
если `CYCLE` то последовательность начинает повторяться с самого начала.


Когда определяем первичный ключ для таблицы, `PRIMARY KEY`
`DEFAULT (nextval('seq_1'))`

```sql
    "id" bigint NOT NULL PRIMARY KEY DEFAULT (nextval('seq_1'))
```

---
Ограничения первичного ключа и последовательности.
---

И так, последовательности можно использовать для первичного ключа таблицы,
при этом может существовать несколько ситуаций при которых могут возникнуть 
проблемы.

Представим себе такую ситуацию, мы создаем последовательность `seq_7` и задаем
ей опции `maxvalue 10 start 1 cycle` что означает что максимальным значением 
последовательности может быть только число `10` и последовательность является
цикличной, то есть при достижении числа `10` последовательность начнет свой 
счет начиная с `1` и так далее...  

```sql
create sequence seq_7 increment 1 maxvalue 10 start 1 cycle;

insert into table_7 (name) values ('qwerty') returning id; 

BEGIN;
CREATE TABLE "table_7" 
(
 "id" bigint NOT NULL primary key default (nextval('seq_7')), 
 "name" varchar(255) null
);
COMMIT;
```

Но в случае если первичный ключ таблицы определен с параметром `primary key`
то в таблице не может быть записи с одинаковыми `id`, сама последовательность
может повторяться потому что она циклична, но ее значение не может стать значением
первичного ключа, и мы получим ошибку типа:

```
SQL Error [23505]: ERROR: duplicate key value 
violates unique constraint "table_7_pkey" 
Detail: Key (id)=(1) already exists.
```

Другой проблемой может служить ограничение самой последовательности если она
создана как не цикличная `no cycle` то по достижению максимального значения 
`10` последовательность не сможет повторяться и мы получим ошибку, соответственно
такая последовательность может быть источником данных для первичного ключа, но 
только до своего максимального значения.

```sql
create sequence seq_6 increment 1 maxvalue 10 start 1 no cycle;

select nextval('seq_6');
```

Ошибка
```
SQL Error [2200H]: 
ERROR: nextval: reached maximum value of sequence "seq_6" (10)
```
