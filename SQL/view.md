Представления
---

В `postgres` есть возможность создавать представления, `view` представляют собой 
результат запросов, который будет сохранен для переиспользования, представления
сохраняются в своем под пространстве имен, по сути представления это витрина с данными
выборки.

Представления созданные раз изменить нельзя.

Пример создания представления
```sql
CREATE VIEW view_name AS
  SELECT name, title, count
  FROM table_name
  WHERE count > 1000
  ;
```

---
Представления используются в случае:
---

1) Повторное использование `SQL`
2) После создания сложного запроса его можно легко использовать
3) Вывод фрагментов таблицы в место всей таблицы
4) Представления дают доступ к подмножеству таблиц, а не ко всем таблицам
5) Представления могут изменять данные и выводить их не так как те 
хранятся в таблицах.

Созданные представления можно использовать и работать с ними как 
с реальными таблицами, фильтровать группировать и сортировать,
объединять одни представления с другими представлениями.

Представления это виртуальные таблицы данные которых хранятся в других
реальных таблицах, так что если реальные данные в таблицах изменятся
то и изменятся данные возвращаемые самими представлениями.

---
Общие правила и ограничения представлений:
---

- Представления, как и таблицы должны иметь уникальные имена, и не 
  должны пересекаются с реальными таблицами.

- Можно создать сколько угодно представлений

- Представления могут быть вложенными 

- Иногда запрещается использовать `ORDER BY` фильтрацию в запросах
  представлений

- Иногда требуется использовать псевдонимы для возвращаемых столбцов

- Представления нельзя индексировать и они не могут иметь триггеров

---

Предположим что у нас есть запрос что объединяет 3 таблицы, и получает данные
по условию `WHERE`.

```sql
    SELECT name, contact
    FROM Customers, Orders, OrderItem
    WHERE Customers.cust_id = Orders.cust_id
    AND OrderItem.order_num = Orders.order_num
    AND prod_id = 'RGAN01';
```

Теперь предположим что весь этот запрос можно сохранить в виде
Динамически сгенерированной таблицы `ProductCustomers`.

Тогда уже имея эту новую таблицу, можно извлечь из нее данные
при помощи след запроса.

```sql
    SELECT name, contact
    FROM ProductCustomers
    WHERE prod_id = 'RGAN01';
```

Таблица `ProductCustomers` и называется представлением, она не хранит
столбцов с их описанием, в место этого она хранит сам запрос.

---
Создание представлений. `CREATE VIEW`, `DROP VIEW`
---

Создаются представления при помощи `CREATE VIEW` по аналогии с 
`CREATE TABLE`. Такую инструкцию можно использовать только для 
создания представления. 

Удаления представления происходит при помощи `DROP VIEW`. Обновить
представление не получится так что просто удаляем его и создаем заново.

```sql
    // Создаем представление
    CREATE VIEW ProductCustomers AS

    // Далее указываем просто сам запрос
    SELECT name, contact, prod_id
    FROM Customers, Orders, OrderItem
    WHERE Customers.cust_id = Orders.cust_id
    AND OrderItem.order_num = Orders.order_num;
```

Эта команда создает представление с названием ProductCustomers.
После этого если сделать запрос типа:

```sql 
    SELECT * 
    FROM ProductCustomers;
```

То получим всех клиентов сделавших заказ, то есть в таблице
ProductCustomers уже будут находиться все записи объединенные по 
условию:

```sql
    WHERE Customers.cust_id = Orders.cust_id
    AND OrderItem.order_num = Orders.order_num;
```

Когда мы делаем извлечение данных из представления, то просто
берется наше условие в SELECT и добавляется к условию выборки 
самого представления.

---
Создание Представления с переформатированием извлекаемых данных.
---

Также представления часто используются для изменения формата
возвращаемых данных, к примеру:

```sql
    SELECT CONCAT(vend_name || ' ( ' || vend_country ||' ) ' )
    AS vend_title
    FROM Vendors
    ORDER BY vend_name;
```

Данный запрос не просто измает данные и соединяет 2 поля в одно, 
так образ запрос вернет данные не в том формате в котором данные 
хранятся в таблице.

Создадим представление для этого запроса:
    
```sql
    CREATE VIEW VendorLocatiob AS
    SELECT CONCAT(vend_name || ' ( ' || vend_country ||' ) ' )
    AS vend_title
    FROM Vendors;
```

---
Простое `view` переадресует `CRUD` на оригинальную таблицу 
---
В `Postgres` имеется уникальная особенность, при использовании `CRUD` операций на
представлении, при условии, что представление является простым, то есть в представлении 
выборка происходит из одной единственной таблицы, то в таком случае все `CRUD` 
операции направленные на представление будут переадресованы на оригинальной таблицу,
и все операции удаления, изменения ... будут применимы с реальной таблице в БД.

Простейшее представление:
```sql
CREATE VIEW view_name AS
  SELECT *
  FROM table_name
;
```

Чем нам это может помочь, в `postgres` нет возможности изменить порядок уже 
существующих столбцов в таблице, так же и нет возможности вставить новый столбец
в нужное место, все новые столбцы будут добавляться всегда только в конец таблицы.

В случае если нам требуется изменить порядок столбцов в таблице то вместо 
пересоздания всей таблицы, мы можем создать на нее представление и использовать 
его в место самой таблицы, благодаря уникальной фичи `postgres` с переадресацией, 
это позволит не пересоздавая таблицу, работать с ней как если бы все столбцы были
в указанном порядке, и в то же время не сохраняется возможность `CRUD` операций над 
таблицей.
