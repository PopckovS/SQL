
Комментарии в `SQL` записываются после спец символов `--`

Первичные ключи:
1) 2 разных строки не могут содержать одно значение первичного ключа.
2) Каждая строка должна иметь значение, оно не может быть NULL.
3) Значения нельзя использовать дважды, если удален то переиспользовать нельзя.

---
Создание Алиасов
---

Каждому изымаемому полю можно сопоставить алиас, как при помощи 
ключевого слова `AS` или даже без него, просто при помощи пробела.

По дефолту алиас можно задавать без кавычек, в таком случае все буквы 
алиаса будут приведены в нижний регистр, чтобы иметь возможность задавать 
алиас с регистром и с пробелами, то следует задавать алиас в кавычках.

Пример работает:

```sql
    SELECT 
        actor_id IdentityOfActor,
        first_name as "FirstName",
        last_name as "Last Name",
        last_update "Last Update"
    FROM 
        actor;
```

В случае если мы используем вычисляемые поля, из одного и того же поля,
то только первое поля будет иметь название `amount` все остальные 
будут иметь название не известного атрибута `?column?` по этому алиасы 
давать надо.

```sql
    SELECT
        amount,
        amount / 2 as "HalfAmount",
        amount * 10 as "AmountMyltiply10",
        amount * amount as "AmountSquared"
    FROM
        payment;
```

---
№1 Извлечение одного или нескольких столбцов, 
---

Получить всю колонку, все записи одного атрибута, из одной таблицы.

```sql
    -- Оба варианта равноценны
    SELECT prod_name
    FROM Products;

    -- Или этот вариант 
    SELECT Products.prod_name 
    FROM Products;

    -- Ответ вся колонка
    Product #1
    Product #2
    Product #3
```

Аналогично это будет работать и с извлечением нескольких столбцов таблицы. 

```sql
    SELECT prod_id, prod_name, prod_price 
    FROM Products;
```

---
№2 Извлечение всех столбцов таблицы
--

Можно извлекать все столбцы со что есть в таблице, для этого указываем 
`SELECT *` это извлечет все столбцы таблицы.

```sql
    -- Получить все столбцы в таблице
    SELECT * 
    FROM Products;
```

---
№3 Извлечение только уникальных строк `DISTINCT`.
---

Можно выбрать все записи из колонки, но эти записи могут повторяться, для
того чтобы выбрать только уникальные записи из колонки, следует использовать 
специальный оператор `DISTINCT`.

```sql
    -- Изьять все записи из колонки 
    SELECT vend_id
    FROM Products;

    -- Ответ: изьяты все записи и они дублируются
    BRS01
    DLL01
    FNG01
    BRS01
    DLL01
    FNG01
```

```sql
    -- Изьять из колонки только уникальные значения
    SELECT DISTINCT vend_id
    FROM Products;

    -- Ответ: только уникальные начения
    BRS01
    DLL01
    FNG01
```

Ключевое слово `DISTINCT` применяется ко всем столбцам, а не только к тем 
перед которым оно стоит, сделаем выборку уникальных значений сразу по 2 
столбцам, и увидим что не которые поля дублируются, Но сама строка 
целиком, именно по 2 значениям из столбцов всегда уникальны и не
дублируются, то есть `DISTINCT` обеспечивает уникальность по всей строке,
со всеми ее значениями.

```sql
    SELECT DISTINCT vend_id, prod_price
    FROM Products;

    DLL01 3.49
    BRS01 5.99
    BRS01 8.99
    FNG01 9.49
```

Как можем видеть в ответе, есть одинаковые поставщики, но сумарно по обоим 
полям, строки уникальны и не дублируются. 

---
Количество уникальных записей `DISTINCT` + `COUNT`
--

Для получения уникальных записей по столбцу, можно использовать специальный оператор
`DISTINCT`.

В случае когда нам требуется получить уникальное количество записей, то есть использовать
`DISTINCT` в сочетании с агрегирующей функцией `COUNT` мы не можем просто указать так:

```sql
SELECT DISTINCT
	count(actor.first_name) 
FROM 
	actor
;
```

Ключевое слово `DISTINCT` не работает с `COUNT`, для того чтобы получить нужный
результат, нам требуется указать `DISTINCT` внутри самой агрегирующей функции 
`COUNT(DISTINCT table.field)`

Задача: получить количество всех записей и количество уникальных записей
по столбцу `first_name` из таблицы `actor`

```sql
SELECT 
	count(actor.first_name) AS "Total count"
	,count(DISTINCT actor.first_name) AS "Distinct count"
FROM 
	actor
;
```
Ответ

| Total count | Distinct count |
|-------------|:--------------:|
| 200         |      128       |  


---
№4 Ограничение результатов запроса `LIMIT` и `OFFSET`
---

Для ограничения выборки, чтобы указать сколько строк мы хотим выбрать, и с 
какой позиции, используется ключевое слово `LIMIT`, `OFFSET` - указывает сколько
строк, требуется пропустить с самого начала. 

Получаем первые 5 записей
```sql
    --Выбрать первые пять записей с 1 по 5 
    SELECT prod_name
    FROM Products
    LIMIT 5;
```

Получаем первые 5 записей после 5 записей
```sql
    --Выбрать 5 строк с верху пропустив первые 5 строк
    SELECT prod_name
    FROM Products
    LIMIT 5 OFFSET 5;
```

Таким образом мы всегда получаем записи из отсортированного по возрастанию порядка,
как же можно получить записи с обратного конца, отсортированных по убыванию, от
большего к меньшему.

Для этого мы с начала сортируем по убыванию, а после выбираем нужные срезы записей

```sql
    --Выбрать 5 строк с низу пропустив последние 5 строк
    SELECT prod_name
    FROM Products
    ORDER BY id DESC
    LIMIT 5 OFFSET 5;
```

---
№5 Сортировка полученных данных `ORDER BY`
---

При выборке, данные возвращаются в рандомном неупорядоченном порядке, 
для их сортировки используется слово `ORDER BY` после него указываются 
один или несколько столбцов по которым будет идти сортировка, начала 
по одному полю, потом по другому.

```sql
    --Произвольный порядок
    SELECT prod_name
    FROM Products;

    --Неотсортированные данные
    Bird bean bag toy
    12 inch teddy bear
    8 inch teddy bear
    18 inch teddy bear

    --Отсортированные по полю prod_name
    SELECT prod_name
    FROM Products
    ORDER BY prod_name;

    --Отсортированные данные
    12 inch teddy bear
    18 inch teddy bear
    8 inch teddy bear
    Bird bean bag toy
```

Обычно колонка по которой происходит сортировка, отображается в запросе `SELECT`
однако это не обязательно, и сортировать можно по полю которое не будет 
включено в запрос `SELECT`.


Также можно указать сортировку по номеру извлекаемого столбца, 

```sql
    SELECT prod_id, prod_prie, prod_name
    FROM Products
    ORDER BY 2, 3 
```

Однако в таком случае необходимо обезательно указывать поля по которым 
сортируем в выборке SELECT. 

---
№6 Указать направление сортировки `ASC` или `DESC`
---

Стандартно данные сортируются по возрастания от А...Я от 1...100 этот способ 
сортировки указывается словом `ASC` или же стоит по умолчанию. Для того чтобы казать 
сортировку в обратном порядке от большего к меньшему от 100...1 от Я...А
то требуется указать ключевое слово `DESC`.

```sql
    --Данные выбирается таким же образом как и в первом примере
    --Но сортируются в обратном порядке
    SELECT prod_name
    FROM Products
    ORDER BY prod_name DESC;

    --Отсортированные данные
    Bird bean bag toy
    8 inch teddy bear
    18 inch teddy bear
    12 inch teddy bear
```

ASC и DESC применяется только к тому столбу перед которым оно стоит.

Эти ключевые слова являются сокращениями от:

`ASC`  -> `DESCENDING`

`DESC` -> `ASCENDING`

Так же мы можем указывать несколько полей для сортировки, скажем у нас есть данные по
оплате и дате этой оплаты, тогда мы можем отсортировать с начала по оплате, по убыванию,
таким образом отсортированные данные будут представлять собой несколько групп,
разделенных по сумме, а внутри каждой из этих групп, данные будут отсортированы по
возрастанию.

```sql
SELECT 
	p.amount 
	,payment_date
FROM 
	payment AS p
ORDER BY 
	p.amount DESC
	,payment_date ASC
;
```

Результат: по сумме данные отсортированы по убыванию, а по дате по возрастанию.

| amount |        payment_date         |
|--------|:---------------------------:|
| 11.99  | 	2007-03-02 20:46:39.996577 |
| 11.99  | 	2007-03-21 21:57:24.996577 |
| 11.99  | 	2007-03-21 22:02:26.996577 |
| 11.99  | 	2007-03-22 22:17:22.996577 |
| 11.99  | 	2007-03-23 20:47:59.996577 |
| 11.99  | 	2007-04-06 21:26:57.996577 |
| 11.99  | 	2007-04-07 19:14:17.996577 |
| 11.99  | 	2007-04-29 21:06:07.996577 |
|        |                             |
| 10.99  | 	2007-02-15 08:14:59.996577 |
| 10.99  | 	2007-02-15 16:59:12.996577 |
| 10.99  | 	2007-03-16 13:20:28.996577 |
| 10.99  | 	2007-03-17 02:33:38.996577 |
| 10.99  | 	2007-04-17 16:37:30.996577 |
| 10.99  | 	2007-04-18 07:01:49.996577 |
| 10.99  | 	2007-05-19 09:18:28.996577 |

---
№7 Фильтрация данных `WHERE`
---

Позволяет выбирать данные у которых есть некий признак

```sql
    SELECT prod_name, prod_price
    FROM Products
    WHERE prod_price = '3.49';
```

Сортировка `ORDER BY` должен идти после выборки `WHERE`

Операторы для поиска в условии `WHERE` :

```
    =     Равенство
    <>    Неравенство
    !=    Неравенство
    <     Меньше
    <=    Меньше равно
    !<    Не меньше
    >     Больше
    >=    Бельше равно
    !>    Не больше
    BETWEEN Находится в диапазоне значений 
    IS NULL равно спец типу `NULL`
```

Примеры:
    
```sql
    --Там где цена меньше 10
    WHERE prod_price < 10

    --Равно 10 или меньше этого
    WHERE prod_price <= 10

    --Внешние ключи могут быть не только id типа, но и типа varchar, то есть строкой
    --Получить запись из таблицы где столбец с названием vend_id являющийся внешним
    --ключом к другой таблице равен DLL01
    WHERE vend_id = 'DLL01';

    --Получить все записи кроме DLL01
    WHERE vend_id <> 'DLL01';
    WHERE vend_id != 'DLL01';

    --Получить данные в промежутке значений
    WHERE prod_price BETWEEN 5 AND 10;

    --Ответ
    5.99
    8.99
    9.99
    9.99
```


№8 Расширенная фильтрация данных `WHERE`, `AND`, `OR`, `NOT`, `IN`. 
---

- `OR` возвращает если запись удовлетворяет одному из двух условий
- Оператор `IN` указывает что надо извлечь данные из списка указанных значений
- Оператор `IN` равносилен оператору `OR`
- Оператор `NOT` равносилен `<> `или `!= `
- Порядок обработки оператора `AND` выше чем у `OR`
   
```sql     
    -- Будут выбраны товары этих поставщиков
    SELECT * 
    FROM table_1
    WHERE vend_id IN ('DLL01', 'BRS01')
```

№9 Фильтрация по регулярному выражению `NOT LIKE`, `LIKE` и `ILIKE`
---

Позволяет искать строковые данные в секции `WHERE` по регулярному
выражению.

Специальные символы для поиска в регулярном выражении:
```
    %   -  любое количество символов

    _   -  только один любой символ

    []  -  любой из переданных в скобки символов
    [JM]% - любая строка начинающаяся с символа J или M

    [^JM]% - символ ^ означает НЕ, то есть найти 
            все что не начинается с J или M
```

`LIKE()` - поиск в точном соответствии с указанным шаблоном.

`NOT LIKE()` - поиск всего что не входит в искомый шаблон.

`ILIKE()` - поиск в точном соответствии с шаблоном, но без учета 
регистра символов.

---

```sql
-- Поиск всех записей с любым количеством символов, заканчивается на символ `o`
SELECT *
FROM Ships
WHERE class LIKE '%o' ;
```
