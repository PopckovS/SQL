Postgres Часть 3
---

---
Создание Алиасов
---
Каждому изымаемому полю можно сопоставить алиас, как при помощи 
ключевого слова `AS` или даже без него, просто при помощи пробела.

По дефолту алиас можно задавать без кавычек, в таком случае все буквы 
алиаса будут приведены в нижний регистр, чтобы иметь возможность задавать 
алиас с регистром и с пробелами, то следует задавать алиас в кавычках.

Пример работает:

    select
        actor_id IdentityOfActor,
        first_name as "FirstName",
        last_name as "Last Name",
        last_update "Last Update"
    from 
        actor;

В случае если мы используем вычисляемые поля, из одного и того же поля,
то только первое поля будет иметь название `amount` все остальные 
будут иметь название не известного атрибута `?column?` по этому алиасы 
давать надо.
    
    select 
        amount,
        amount / 2 as "HalfAmount",
        amount * 10 as "AmountMyltiply10",
        amount * amount as "AmountSquared"
     from 
        payment;

---
Конкатенация строк
---
Что бы соединить 2 строки между собой, это можно сделать при помощи символа 
`||` в результате 2 строки будут соединены.

    -- Конкатенация при помощи символа ||
    select 
        a.address || ' ' || a.district,
        *
    from 
        address a ;

Другой способ конкатенации это использование функции concat() 

    -- Конкатенацпия функцией concat()
    select 
        concat(a.address, ' ', a.district),
        *
    from 
        address as a;

---
`distinct`
---
Ключ слово DISTINCT применяется к конкретному атрибуту, и изымает только
уникальные значения по этому полю, то есть все дубликаты будут отсеяны.

    select 
	    distinct amount
    from
	    payment p;

Использование DISTINCT на получение всех полей `*` имеет смысла, ибо 
все поля будут уникальны, и результаты будут одинаковы.

    select 
	    distinct *
    from
        actor a 
    order by 
        actor_id ;

Также можно извлекать уникальные записи по 2 полям, будут возвращены 
только те записи, которых уникальная комбинация этих 2 атрибутов, если всего 
записей 200, а данный запрос возвращает 199, то это значит что из 200 записей
2 записи полностью повторяются:

    select 
	    distinct a.first_name, a.last_name 
    from
	    actor a;

---
Группировки
---

Найдем количество записей которые повторяются более 1 раза полю Имени.

    SELECT 
         first_name, count(*) as FirstNameCounter
    FROM 
        actor AS a
    GROUP BY
        first_name
    HAVING 
        count(first_name) > 1;

Найдем поля у которых, записи не уникальны по 2 полям, записи у 
которых 2 поля содержат повторяющиеся значения.

    SELECT 
	    first_name, last_name
    FROM 
        actor AS a
    GROUP BY 
        first_name, last_name 
    HAVING 
        count(first_name) > 1;	

---
Методы `NOW(), INTERVAL '...'`
---

Получить дату и время

    SELECT NOW(); 
    2021-05-24 06:54:39

Фильтрация даты

    SELECT NOW()::DATE;
    2021-05-24

Фильтрация на время

    SELECT NOW()::TIME;
    06:56:17

Функция `INTERVAL` добавляет/вычитает из даты время:

    SELECT NOW() - INTERVAL '1 YEAR';
    2020-05-24 06:58:16

Синтаксис для других дат:

    1 YEAR
    10 MONTS
    10 DAYS


---
EXTRACT()
---
Используется для извлечения части даты/времени, к примеру извлечь 
только год из текущего времени/даты:

    SELECT EXTRACT(YEAR FROM NOW());
    2021.0

Синтаксис для извлечения:

    YEAR
    MONTH
    DAY
Также можно извлекать и дни недели.

Получить день недели по счету:

    SELECT EXTRACT (DOW FROM NOW());

---
Функция AGE()
---
AGE() это функция, которая позволяет узнать возраст, по сути 
вычитает из указанной даты/времени другую дату время.

Из текущей дата/время вычтем дату, получим дату время их разницы.

    SELECT AGE(NOW(), '2000-12-12');
    20 years 5 mons 12 days 07:07:40.688152

Комбинацией `EXTRACT` и `AGE` получим год из разницы даты/времени.

    SELECT EXTRACT(YEAR FROM AGE(NOW(), '2000-12-12'));


---
Фильтр ::DATE
---
2 даты можно просто вычесть друг из друга, предварительно приведя 
строки к датам. 

    select '2015-01-11'::date - '2015-01-01'::date;

    // Ответ в днях
    10 